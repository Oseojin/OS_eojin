# 03. 세그먼테이션과 메모리 주소 지정 (Segmentation & Addressing)

이 문서는 리얼 모드(16-bit Real Mode)의 핵심이자 가장 난해한 개념 중 하나인 **세그먼테이션(Segmentation)**과 메모리 주소 계산 방식을 설명합니다.

## 1. 16비트의 한계와 해결책

초기 8086 CPU는 **16비트 레지스터**를 가지고 있었습니다.
16비트로 표현할 수 있는 숫자의 범위는 `0` ~ `65,535` (0xFFFF)입니다.
즉, 한 번에 가리킬 수 있는 메모리 주소가 **64KB**밖에 되지 않습니다.

하지만 당시에도 64KB는 너무 작았기에, 인텔은 **1MB (1,048,576 바이트)**까지 메모리를 쓰고 싶었습니다. 이를 위해 **세그먼트(Segment)**와 **오프셋(Offset)**이라는 개념을 도입했습니다.

## 2. 세그먼테이션 공식

물리 주소(Physical Address)를 계산하는 공식은 다음과 같습니다.

$$ \text{Physical Address} = (\text{Segment} \times 16) + \text{Offset} $$

-   **Segment**: 시작 위치를 지정하는 덩어리 (Base).
-   **Offset**: 시작 위치로부터 얼마나 떨어져 있는지를 나타내는 값.
-   **x 16**: 16진수로 보면 왼쪽으로 한 자리 미는 것(`<< 4`)과 같습니다.

### 예시
-   Segment: `0x07C0`
-   Offset: `0x0000`

계산: `(0x07C0 * 0x10) + 0x0000` = `0x7C00` + `0` = **`0x07C00`**

이 방식 덕분에 16비트 레지스터 두 개(Segment + Offset)를 조합하여 20비트 주소(`0xFFFFF` ≈ 1MB)까지 접근할 수 있게 되었습니다.

## 3. 세그먼트 레지스터의 역할

CPU는 용도에 따라 다른 세그먼트 레지스터를 자동으로 참조합니다.

| 레지스터 | 이름 | 용도 | 자동 참조 상황 |
| :--- | :--- | :--- | :--- |
| **CS** | Code Segment | 실행할 코드의 위치 | 명령어 실행 (IP와 조합) |
| **DS** | Data Segment | 데이터의 위치 | 일반 데이터 접근 (`MOV`, `LODSB` 등) |
| **SS** | Stack Segment | 스택의 위치 | 스택 연산 (`PUSH`, `POP`, `SP`) |
| **ES** | Extra Segment | 추가 데이터 위치 | 문자열 복사 등 (`DI`와 조합) |

## 4. 왜 초기화가 필요한가?

BIOS가 부트로더를 실행해줄 때, `CS`는 `0`으로 설정되어 있을 수도 있고, `0x07C0`으로 설정되어 있을 수도 있습니다 (BIOS 제조사마다 다름). 하지만 우리는 코드를 `[ORG 0x7C00]` 기준으로 작성했으므로, **모든 세그먼트 레지스터를 0으로 명확하게 설정**해 주어야 오프셋 계산이 꼬이지 않습니다.

특히 `DS`(Data Segment)가 엉뚱한 값을 가지고 있다면, `msg` 변수의 주소를 읽을 때 `DS * 16 + msg_offset` 계산이 잘못되어 엉뚱한 메모리를 읽게 됩니다.

### 초기화 코드 패턴
세그먼트 레지스터에는 상수(Immediate value)를 직접 넣을 수 없습니다. 반드시 범용 레지스터(`AX`)를 거쳐야 합니다.

```nasm
xor ax, ax      ; AX = 0
mov ds, ax      ; DS = 0
mov es, ax      ; ES = 0
mov ss, ax      ; SS = 0
mov sp, 0x7C00  ; 스택 포인터(SP) 설정 (부트로더 아래쪽 안전한 공간)
```

