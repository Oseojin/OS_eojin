# 힙 메모리 할당기 (Heap Allocator) - Free List 방식

## 1. 힙(Heap)이란?
운영체제 커널이나 응용 프로그램이 실행 중에 **동적으로** 필요한 만큼 할당받고, 다 쓰면 반납하는 메모리 영역입니다. 
- PMM(물리 메모리 관리자)은 4KB(페이지) 단위로만 큼직하게 메모리를 줍니다.
- 힙 할당기(Heap Allocator)는 이 페이지를 받아와서 바이트 단위로 잘게 쪼개어 줍니다 (`malloc`).

## 2. 연결 리스트(Linked List) 기반 할당기
가장 기본적인 동적 할당 알고리즘입니다. 해제된(Free) 메모리 블록들을 연결 리스트로 엮어서 관리합니다.

### 2.1. 메모리 블록 헤더 (Header)
모든 메모리 조각(청크, Chunk)의 바로 앞에는 **헤더**라는 관리 정보가 붙어 있어야 합니다.

```c
typedef struct block_header {
    struct block_header *next; // 다음 빈 블록을 가리킴
    uint64_t size;             // 현재 블록의 크기 (헤더 제외)
    uint8_t is_free;           // 사용 가능 여부 (1=Free, 0=Used)
} block_header_t;
```

사용자가 `malloc(100)`을 요청하면 실제로는 `sizeof(header) + 100` 만큼의 공간이 필요합니다.

### 2.2. 할당 알고리즘 (Allocation)
1. **탐색:** `head`부터 시작해서 리스트를 순회하며 요청한 크기보다 크거나 같은 빈 블록(`is_free == 1`)을 찾습니다. (First Fit 전략)
2. **분할 (Splitting):** 찾은 블록이 요청한 크기보다 훨씬 크다면, 두 개로 쪼갭니다.
   - 앞부분: 요청자에게 할당 (Used)
   - 뒷부분: 남은 자투리는 다시 빈 블록(Free)으로 리스트에 유지.
3. **확장:** 리스트 끝까지 갔는데도 공간이 없다면?
   - PMM에게 새 페이지(4KB)를 요청합니다.
   - 새 페이지를 리스트 끝에 붙이고 할당을 진행합니다.

### 2.3. 해제 알고리즘 (Free)
1. 사용자가 포인터를 넘겨주며 `free(ptr)`를 호출합니다.
2. 포인터 바로 앞의 **헤더**를 읽습니다.
3. `is_free`를 1로 변경합니다.
4. **병합 (Coalescing):** (선택 사항이지만 중요)
   - 방금 해제한 블록의 바로 다음 블록도 Free 상태라면, 두 블록을 하나로 합칩니다.
   - 이렇게 해야 메모리 파편화(Fragmentation)를 막을 수 있습니다.

## 3. 장단점
- **장점:** `malloc`과 `free`를 완벽하게 지원하며, 메모리 재사용이 가능합니다.
- **단점:** 헤더 크기만큼 메모리 오버헤드가 있으며, 리스트 탐색 시간(O(N))이 걸립니다. 또한 장시간 사용 시 외부 단편화 문제가 발생할 수 있습니다.
