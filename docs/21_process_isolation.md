# 21. 프로세스 격리 (Process Isolation)

이 문서는 가상 메모리 기술을 활용하여 각 프로세스에게 독립적인 주소 공간을 제공하는 방법을 설명합니다. 이를 통해 한 프로세스가 다른 프로세스의 메모리를 침범하거나 커널의 중요 데이터를 훼손하는 것을 방지할 수 있습니다.

## 1. 개요

현재 OS_eojin은 모든 프로세스가 하나의 **커널 PML4**를 공유합니다. 이는 **Identity Mapping** (가상 주소 = 물리 주소) 방식이며, 모든 메모리가 모든 프로세스에게 노출되어 있습니다.

진정한 멀티태스킹 OS를 위해서는 다음이 필요합니다:
1.  **독립된 PML4:** 각 프로세스 생성 시 고유한 최상위 페이지 테이블(PML4)을 할당합니다.
2.  **커널 공간 공유:** 모든 PML4는 상위 주소(또는 특정 영역)에 커널 영역을 공통적으로 매핑해야 합니다. (시스템 콜 및 인터럽트 처리를 위해).
3.  **유저 공간 격리:** 하위 주소(유저 영역)는 각 프로세스마다 서로 다른 물리 메모리를 가리킵니다.
4.  **CR3 스위칭:** 컨텍스트 스위칭(`schedule`) 시 CPU의 `CR3` 레지스터를 다음 프로세스의 PML4 주소로 갱신합니다.

## 2. 메모리 레이아웃 설계 (임시)

복잡한 Higher Half Kernel로 가기 전, 과도기적 모델을 사용합니다.

*   **0x000000 ~ 0x8000000 (0~128MB):** **커널 영역 (Identity Mapped)**
    *   모든 프로세스의 페이지 테이블에 공통적으로 매핑됩니다.
    *   커널 코드, 데이터, 비디오 메모리, PMM 비트맵 등이 포함됩니다.
    *   이 영역은 `User=0` (커널 전용)으로 설정하여 보호해야 하지만, 현재는 시스템 콜 호출 시 편의를 위해 `User=1`로 둘 수도 있습니다. (보안 강화 시 수정).

*   **0x10000000 (256MB) ~ ... :** **유저 영역**
    *   각 프로세스마다 독립적으로 할당되는 공간입니다.
    *   예: 프로세스 A의 `0x10000000`은 물리 주소 `0x20000000`에 매핑되고, 프로세스 B의 `0x10000000`은 물리 주소 `0x30000000`에 매핑됩니다.

*   **ELF 로드 주소:**
    *   기존에는 `0x1000000` (16MB)에 로드했지만, 이는 커널 영역(128MB 이하)과 겹칩니다.
    *   격리를 테스트하려면 유저 프로그램의 링크 주소를 **128MB 이상**으로 옮겨야 합니다.

## 3. 구현 로직

### 3.1. VMM 확장
*   `vmm_create_user_pml4()`:
    1.  새로운 PML4 페이지를 할당받습니다 (`pmm_alloc`).
    2.  **커널 영역 복사:** 현재 커널 PML4의 엔트리 중 커널 영역에 해당하는 부분을 새 PML4에 복사합니다. (이렇게 하면 커널 매핑이 동기화됩니다).
    3.  새 PML4 주소를 반환합니다.

### 3.2. ELF 로딩 (수정)
기존 `elf_load_file`은 `p_vaddr`에 바로 `memcpy`를 했습니다. 격리된 환경에서는 다음과 같이 해야 합니다.

1.  `p_vaddr` (가상 주소)에 대응할 **물리 페이지(`phys_addr`)를 할당**받습니다 (`pmm_alloc`).
2.  새로 만든 **유저 PML4**에 `Map(p_vaddr -> phys_addr)`을 수행합니다.
3.  데이터 복사: `exec` 함수(커널)는 가상 주소 `p_vaddr`에 직접 쓸 수 없습니다 (현재 CR3가 커널 PML4이거나 다른 프로세스의 것일 수 있으므로, 해당 `p_vaddr` 매핑이 없을 수 있음).
    *   **방법 A (임시 매핑):** 커널의 특정 영역에 `phys_addr`를 잠시 매핑하고 복사한 뒤 해제합니다.
    *   **방법 B (Identity Mapping 활용):** 현재 커널은 0~128MB Identity Mapping을 사용합니다. 만약 `phys_addr`가 128MB 이하라면, 그냥 물리 주소를 포인터로 써서 복사하면 됩니다.
    *   PMM이 32MB 이상을 할당해주므로, 128MB 이하라면 직접 접근 가능합니다.

### 3.3. 스케줄러
*   `process_t`에 `uint64_t pml4` (물리 주소) 필드 추가.
*   `schedule()` 함수에서 `current_pid`가 바뀔 때:
    ```c
    vmm_switch_pml4((page_table_t*)next_proc->pml4);
    ```

## 4. 단계별 적용
1.  **구조체 및 VMM 수정:** `process_t` 필드 추가, `vmm_create_user_pml4` 구현.
2.  **ELF 로더 수정:** 물리 메모리 할당 및 매핑 로직 추가.
3.  **스케줄러 수정:** CR3 교체 로직 추가.
