# 문자열 파싱 (String Parsing)

## 1. 쉘(Shell)과 명령어 처리
사용자가 입력한 한 줄의 문자열(Line)은 보통 **명령어(Command)**와 여러 개의 **인자(Arguments)**로 구성됩니다.
예: `echo Hello World`
- 명령어: `echo`
- 인자 1: `Hello`
- 인자 2: `World`

OS 커널은 이 문자열을 의미 있는 단위(Token)로 쪼개서 해석해야 합니다.

## 2. 토크나이징 (Tokenizing)
문자열을 특정 **구분자(Delimiter)**를 기준으로 자르는 과정입니다. 쉘에서는 주로 **공백(Space, 0x20)**이 구분자가 됩니다.

### 2.1. 알고리즘
1. **Skip Delimiters:** 현재 위치에서 공백이 아닐 때까지 인덱스를 증가시킵니다.
2. **Start Token:** 문자가 시작되는 지점을 기록합니다.
3. **Find End:** 다시 공백이나 문자열 끝(NULL)이 나올 때까지 인덱스를 증가시킵니다.
4. **Extract:** 시작 지점부터 끝 지점까지의 문자열을 복사하여 하나의 토큰으로 만듭니다.
5. **Repeat:** 문자열 끝에 도달할 때까지 위 과정을 반복합니다.

### 2.2. `strtok` vs `get_next_token`
- **Standard `strtok`:** 원본 문자열의 공백 위치에 `NULL` 문자를 덮어씌워 문자열을 파괴(Modify)하면서 토큰을 반환합니다. 메모리 효율적이지만 원본이 손상됩니다.
- **Non-destructive Parser:** 원본은 그대로 두고, 토큰을 별도의 버퍼에 복사하는 방식입니다. `malloc`이 필요하거나 고정 버퍼를 사용해야 하지만 원본 보존이 장점입니다.

## 3. 구현 시 주의사항
- **연속된 공백:** `ls    -la` 처럼 공백이 여러 개일 때 빈 토큰이 생성되지 않도록 처리해야 합니다.
- **버퍼 오버플로우:** 토큰을 복사할 때 버퍼 크기를 넘지 않도록 체크해야 합니다.
- **따옴표 처리:** 고급 쉘은 `"Hello World"`를 하나의 인자로 처리하지만, 초기 단계에서는 단순히 공백 기준으로만 자르는 것이 좋습니다.
