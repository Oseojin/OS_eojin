# 키보드 스캔코드 (Keyboard Scancodes)

## 1. 키보드 동작 원리
키보드는 문자를 직접 보내지 않습니다. 대신 사용자가 키를 누르거나 뗄 때 **스캔코드(Scancode)** 라는 고유한 숫자를 발생시킵니다. 운영체제(커널)는 이 숫자를 받아 적절한 문자(ASCII)로 변환하거나, 특수 기능(Shift, Ctrl 등)을 처리해야 합니다.

### 1.1. PS/2 컨트롤러
- **포트:** `0x60` (Data Port), `0x64` (Status/Command Port)
- x86 시스템의 레거시 인터페이스이지만, USB 키보드도 BIOS/UEFI의 **Legacy Emulation** 기능을 통해 PS/2처럼 동작하도록 에뮬레이션 됩니다.

## 2. 스캔코드 셋 (Scancode Sets)
키보드는 역사적으로 세 가지 스캔코드 셋(1, 2, 3)을 지원하지만, 대부분의 OS 개발에서는 **Scancode Set 1**을 기준으로 처리합니다. (컨트롤러가 변환해 줌)

### 2.1. Make Code & Break Code
- **Make Code:** 키를 **눌렀을 때** 발생하는 코드.
- **Break Code:** 키를 **뗐을 때** 발생하는 코드. (보통 `Make Code + 0x80` 값)

**예시:** 'A' 키
- 누름 (Make): `0x1E`
- 뗌 (Break): `0x9E` (`0x1E | 0x80`)

### 2.2. 확장 키 (Extended Keys)
화살표 키, Home, End, 오른쪽 Ctrl/Alt 등은 `0xE0` 바이트가 먼저 전송되고, 그 뒤에 본래 스캔코드가 따라옵니다.
- 예: 왼쪽 화살표 (`0xE0`, `0x4B`)

## 3. ASCII 변환 (Translation)
스캔코드는 물리적인 키의 위치 정보일 뿐입니다. 이를 'A', 'b', '!', '?' 같은 문자로 바꾸려면 **매핑 테이블(Lookup Table)** 이 필요합니다.

### 3.1. 1차원 배열 매핑
가장 간단한 방법은 배열의 인덱스를 스캔코드로, 값을 ASCII 문자로 사용하는 것입니다.

```c
char scancode_to_ascii[256] = {
    0x0, 0x0, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', 0x0, 
    0x0, 'q', 'w', 'e', 'r', ...
};
```

### 3.2. Shift 처리
Shift 키가 눌렸는지 여부(State)를 저장하는 플래그 변수가 필요합니다.
- Shift 누름 (`0x2A` or `0x36`) -> `shift_pressed = 1`
- Shift 뗌 (`0xAA` or `0xB6`) -> `shift_pressed = 0`

Shift 상태에 따라 소문자를 대문자로, 숫자를 특수문자(`1` -> `!`)로 변환하는 로직이 추가되어야 합니다.
