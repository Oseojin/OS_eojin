# 11. 페이징과 롱 모드 (Paging & Long Mode)

이 문서는 32비트 보호 모드에서 64비트 롱 모드(Long Mode)로 전환하기 위한 필수 관문인 **페이징(Paging)**의 개념과 구조를 설명합니다.

## 1. 페이징(Paging)이란?

세그먼테이션이 메모리를 "가변적인 크기의 덩어리"로 관리했다면, 페이징은 메모리를 **"4KB 크기의 고정된 조각(Page)"**으로 관리하는 기법입니다.

-   **가상 주소 (Virtual Address)**: 프로그램이 보는 주소.
-   **물리 주소 (Physical Address)**: 실제 RAM의 주소.
-   **페이지 테이블 (Page Table)**: 가상 주소를 물리 주소로 매핑해주는 지도.

롱 모드(64비트)에서는 세그먼테이션 기능이 거의 퇴화하고(Base/Limit 무시), **페이징이 필수**입니다.

## 2. 4단계 페이징 (4-Level Paging)

x86-64 아키텍처는 48비트 가상 주소를 사용하며, 이를 물리 주소로 바꾸기 위해 4단계의 테이블을 거칩니다.

1.  **PML4 (Page Map Level 4)**: 최상위 테이블. `CR3` 레지스터가 이곳을 가리킴.
2.  **PDPT (Page Directory Pointer Table)**
3.  **PD (Page Directory)**
4.  **PT (Page Table)** -> 물리 주소 (Physical Address)

### Identity Mapping (일대일 매핑)
우리는 지금 부트로더/커널 단계이므로, 복잡한 매핑 대신 **"가상 주소 0번지 = 물리 주소 0번지"**가 되도록 단순하게 설정할 것입니다. 이를 **Identity Mapping**이라고 합니다.

## 3. 롱 모드 전환 절차

32비트에서 64비트로 넘어가려면 다음 순서를 엄격하게 지켜야 합니다.

1.  **페이징 구조 생성**: 메모리 어딘가에 PML4, PDPT, PD 테이블을 만듭니다. (PT는 생략하고 Huge Page 사용 가능)
2.  **PAE 활성화**: `CR4` 레지스터의 PAE(Physical Address Extension) 비트를 켭니다.
3.  **CR3 설정**: PML4 테이블의 주소를 `CR3`에 넣습니다.
4.  **Long Mode 활성화**: `EFER` (Extended Feature Enable Register) MSR의 LME 비트를 켭니다.
5.  **페이징 활성화**: `CR0` 레지스터의 PG(Paging) 비트를 켭니다.
6.  **GDT 업데이트**: 64비트용 코드 세그먼트가 포함된 새로운 GDT를 로드합니다.
7.  **Far Jump**: 64비트 코드 영역으로 점프!

## 4. CPUID 확인

모든 CPU가 64비트를 지원하는 것은 아닙니다. (요즘은 다 하지만요.)
`CPUID` 명령어를 통해 다음을 확인해야 합니다.
1.  CPUID 명령어 자체 지원 여부.
2.  Long Mode 지원 여부 (`0x80000001` 기능의 EDX 29번 비트).

## 5. 어셈블리 구현 전략

이 모든 과정은 **어셈블리**로 수행해야 합니다. C언어는 32비트용으로 컴파일되었기 때문에, 64비트 전환 코드는 `src/boot/boot.asm` 또는 별도의 어셈블리 파일에서 처리해야 합니다.

우리는 기존 `boot.asm`을 확장하여 부트로더 단계에서 바로 64비트까지 올려버리는 방식을 택하겠습니다.
