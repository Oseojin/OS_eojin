# 07. C언어 커널 개발 환경 (Freestanding C Kernel)

이 문서는 운영체제가 없는 환경(Bare Metal)에서 C언어로 커널을 개발하기 위한 환경 설정과 주의사항을 설명합니다.

## 1. Freestanding vs Hosted

C 컴파일러에는 두 가지 모드가 있습니다.

-   **Hosted Implementation**: 일반적인 애플리케이션 개발 환경. `stdio.h`, `stdlib.h` 같은 표준 라이브러리가 운영체제 위에서 동작합니다.
-   **Freestanding Implementation**: 운영체제 없이 동작하는 환경. 표준 라이브러리 대부분을 사용할 수 없으며, 오직 `<stdint.h>`, `<stddef.h>` 같은 의존성 없는 헤더만 사용 가능합니다.

OS 개발은 당연히 **Freestanding** 모드여야 합니다.

## 2. 크로스 컴파일러 (Cross Compiler)

우리가 사용하는 리눅스(`gcc`)는 기본적으로 "현재 실행 중인 OS(리눅스)"를 타겟으로 코드를 컴파일합니다. 하지만 우리는 "우리가 만들 OS"를 위해 컴파일해야 합니다.

완벽한 OS 개발을 위해서는 크로스 컴파일러(i686-elf-gcc 등)를 빌드해서 써야 하지만, 초기 학습 단계에서는 시스템의 `gcc`에 **특정 플래그**를 주어 최대한 OS 의존성을 제거하는 방식으로 진행할 수 있습니다.

## 3. 필수 컴파일러 플래그

C 코드를 커널로 사용하기 위해 반드시 필요한 옵션들입니다.

| 플래그 | 설명 | 이유 |
| :--- | :--- | :--- |
| **-ffreestanding** | 표준 라이브러리 미사용 | `main` 함수가 시작점이 아닐 수 있으며, OS 기능을 호출하지 않음. |
| **-m32** | 32비트 모드로 컴파일 | 우리는 32비트 보호 모드에서 실행할 것이므로. (64비트 OS라면 64비트) |
| **-c** | 링크 하지 않음 | 실행 파일이 아닌 오브젝트 파일(.o)만 생성. 링킹은 나중에 따로 함. |
| **-fno-pie** | 위치 독립 코드 비활성화 | 커널은 항상 고정된 메모리 주소(`0x1000`)에 로드되므로 절대 주소를 사용해야 함. |
| **-fno-stack-protector** | 스택 가드 비활성화 | 스택 오버플로우 방지 코드가 OS 기능을 필요로 할 수 있으므로 끔. |

## 4. 엔트리 포인트 (Entry Point)

C언어의 `main()` 함수는 사실 프로그램의 진짜 시작점이 아닙니다. C 런타임(crt0)이 초기화를 마친 후 `main`을 호출하는 것입니다.
OS 개발에서는 런타임이 없으므로, 우리가 직접 어셈블리로 진입점(Entry Point)을 만들어 C 함수를 호출해 줘야 합니다.

### 구조
1.  **`kernel_entry.asm`**: 부트로더가 점프해 오는 곳. `main` 함수를 호출(`call main`)하고 멈춤.
2.  **`kernel.c`**: 실제 C 코드 로직 (`void main() { ... }`).

## 5. 링킹 (Linking)

작성한 어셈블리 엔트리와 C 코드를 하나로 묶어 **바이너리 파일(.bin)**로 만들어야 합니다. 이때 **메모리 주소**가 중요합니다.
우리는 부트로더에서 커널을 `0x1000`에 로드하기로 했으므로, 링커에게 "이 코드는 `0x1000`에서 실행될 거야"라고 알려줘야 합니다.

```bash
ld -m elf_i386 -o kernel.bin -Ttext 0x1000 kernel_entry.o kernel.o --oformat binary
```
